# 实验五：SM2实现优化与应用

## 一、实验目标

1. SM2 实现与优化：掌握 SM2 算法的基本实现方法，并探索优化途径以提高其运算效率。
2. 签名误用 POC 验证：构造签名误用场景，验证因随机数使用不当导致的安全漏洞。
3. 伪造中本聪数字签名：模拟构造伪造签名，深入理解 SM2 算法的潜在风险。

## 二、实验内容

### （一）SM2实现与优化

1. **基本实现**
    - **密钥对生成**：
        - 选择椭圆曲线参数，包括模 P、系数 A 和 B、基点 G 及阶 N。
        - 生成私钥：随机生成介于 1 和 N-1 之间的整数。
        - 计算公钥：通过椭圆曲线点乘运算，将私钥与基点 G 相乘得到。
    - **加密过程**：
        - 选择随机数 k，对基点 G 进行点乘得到 C1。
        - 计算发送方公钥与 k 的点乘结果 S，用于后续密钥推导。
        - 利用 SM3 哈希函数和密钥派生函数（KDF）生成会话密钥 t。
        - 对明文进行异或运算，生成密文 C2。
        - 再次利用 SM3 哈希确保数据完整性，生成摘要 C3。
        - 最终密文由 C1、C3 和 C2 拼接而成。
    - **解密过程**：
        - 收方使用私钥对 C1 进行点乘运算，恢复出 S。
        - 利用 SM3 和 KDF 生成会话密钥 t。
        - 对 C2 进行异或运算，还原明文。
        - 再次利用 SM3 哈希验证与 C3 一致，确保数据完整性。
    - **签名过程**：
        - 根据用户身份信息 ID 等参数，通过 SM3 哈希运算生成 ZA。
        - 对消息 msg 进行 SM3 哈希运算，将哈希结果与 ZA 结合生成 e。
        - 在签名循环中，随机选择 k，对基点 G 进行点乘运算，计算 r 和 s。
        - 签名由 r 和 s 构成。
    - **验证过程**：
        - 根据 ID 等参数生成 ZA。
        - 对 msg 进行 SM3 哈希运算，结合 ZA 得到 e。
        - 计算 t = (r + s) mod n。
        - 通过点乘运算验证。
    - **运行结果**：
    <img src=".\实验结果截图\sm2实现.png">  

2. **优化尝试**
    - **雅可比坐标系的应用**：
        - 在椭圆曲线点运算中采用雅可比坐标系，通过增加一个额外坐标分量 Z，减少运算中的模逆次数，提升计算效率。
    - **预计算与存储**：
        - 对基点 G 的雅可比坐标进行预计算并存储，避免重复计算，节省时间。
    - **点乘算法改进**：
        - 运用二进制展开法并结合雅可比坐标系下的点加和点倍运算，优化点乘过程，降低运算复杂度，增强效率。
    - **运行结果**：
    <img src=".\实验结果截图\sm2优化.png">  

3. **实验结果对比**
 

| 操作类型 | 基本 SM2 时间 (秒) | 优化 SM2 时间 (秒) | 性能提升倍数  |
| ---- | ------------- | ------------- | ------- |
| 加密   | 0.0248        | 0.0046        | 约 5.4 倍 |
| 解密   | 0.0108        | 0.0021        | 约 5.1 倍 |
| 签名   | 0.0232        | 0.0031        | 约 7.5 倍 |
| 验证   | 0.0248        | 0.0041        | 约 6.0 倍 |
| 验证结果 | 成功            | 成功            | -       |

<img src=".\实验结果截图\优化前后性能对比.png"> 

### （二）签名误用 POC 验证

#### 2.2.1 泄露 `k` 导致泄露 `d1`

当 `k` 泄露时，攻击者可以利用 `k` 和签名值 `(r, s)` 来计算出私钥 `d1`：

1. 签名值为：
   $r = e + x_1 \mod n$，
   $s = \frac{1 + d_A^{-1} \cdot k - r \cdot d_A}{d_A} \mod n$

2. 已知 `k`、`r`、`s` 和 `e`，可以通过以下步骤计算出私钥 `d_A`：
   $d_A = \frac{k - s}{s + r} \mod n$

#### 2.2.2 重用 `k` 导致泄露 `d1`

当对不同的消息使用相同的 `k` 进行签名时，攻击者可以通过两个签名值 `(r1, s1)` 和 `(r2, s2)` 来计算出私钥 `d1`：

1. 签名值为：

   $r_1 = e_1 + x_1 \mod n$

   $s_1 = \frac{1 + d_A^{-1} \cdot k - r_1 \cdot d_A}{d_A} \mod n$

   $r_2 = e_2 + x_1 \mod n$

   $s_2 = \frac{1 + d_A^{-1} \cdot k - r_2 \cdot d_A}{d_A} \mod n$

2. 从 `s1` 和 `s2` 的表达式出发：

   $s_1 = \frac{1 + k - r_1 \cdot d_A}{d_A} \mod n$

   $s_2 = \frac{1 + k - r_2 \cdot d_A}{d_A} \mod n$

3. 解方程组得到 `d_A`：
   $d_A = \frac{s_2 - s_1}{s_1 - s_2 + r_1 - r_2} \mod n$

#### 2.2.3 两用户利用 `k`，推测彼此私钥 `d`

当两个用户对不同的消息使用相同的 `k` 进行签名时，攻击者可以通过两个签名值 `(r1, s1)` 和 `(r2, s2)` 来计算出彼此的私钥：

1. 签名值为：

   $r_1 = e_1 + x_1 \mod n$

   $s_1 = \frac{1 + d_{A}^{-1} \cdot k - r_1 \cdot d_{A}}{d_{A}} \mod n$

   $r_2 = e_2 + x_1 \mod n$

   $s_2 = \frac{1 + d_{B}^{-1} \cdot k - r_2 \cdot d_{B}}{d_{B}} \mod n$

2. 由于 `k` 相同，`r1` 和 `r2` 应该相等。攻击者可以利用以下公式恢复 `k`：
   $k = \frac{e_1 - e_2}{s_1 - s_2} \mod n$

3. 使用恢复的 `k` 计算出对方的私钥：
   $d_{A} = \frac{k \cdot s_2 - e_2}{r \cdot s_2} \mod n$
   $d_{B} = \frac{k \cdot s_1 - e_1}{r \cdot s_1} \mod n$

#### 2.2.4 使用相同的 `d` 和 `k` 会导致泄露 `d1`

当使用相同的 `d` 和 `k` 进行 ECDSA 和 Schnorr 签名时，攻击者可以通过两个签名值来计算出私钥 `d`：

1. ECDSA 签名值为：
   $r_{ECDSA} = r$，
   $s_{ECDSA} = s$

2. Schnorr 签名值为：
   $r_{Schnorr} = r$，
   $s_{Schnorr} = k + e \cdot d \mod n$

3. 通过以下公式计算出私钥 `d`：
   $d = \frac{s_{Schnorr} \cdot s_{ECDSA} - e_{ECDSA}}{r_{ECDSA} + e_{Schnorr} \cdot s_{ECDSA}} \mod n$

#### 运行结果
<img src=".\实验结果截图\poc验证.png"> 

### （三）伪造中本聪数字签名


模拟伪造中本聪数字签名的过程，利用了ECDSA算法在特定条件下的漏洞。具体步骤如下：

1. **选择随机数 u 和 v**：生成两个与曲线阶数 `n` 互质的随机数 `u` 和 `v`。这两个随机数将用于构造伪造签名。
2. **计算点 R**：通过椭圆曲线点加运算，计算点 $R = u \cdot G + v \cdot P$，其中 \( G \) 是基点，\( P \) 是公钥。
3. **构造伪造签名参数**：
   - 计算 $e_{1} = (R \cdot u \cdot \text{mul\_inv}(v, n)) \mod n$
   - 计算 $s_{1} = (R \cdot \text{mul\_inv}(v, n)) \mod n$
4. **验证伪造签名**：使用未验证消息的验证算法 `ver_no_m` 验证构造的签名  (e_1, s_1, R)  是否有效。

#### 运行结果
<img src=".\实验结果截图\伪造签名.png"> 


## 三、实验分析

### （一）SM2 实现与优化

**性能提升原因分析** ：
  
  通过采用雅可比坐标系，增加了额外坐标分量 Z，减少了模逆运算次数，而模逆运算是耗时操作，从而有效提升了椭圆曲线点运算效率。
  
  预计算与存储基点 G 的雅可比坐标，避免了重复计算，节省了时间。
  
  改进点乘算法，运用二进制展开法并结合雅可比坐标系下的点加和点倍运算，降低了运算复杂度，使得加密、解密、签名和验证等操作的时间都有了显著降低，性能得到了数倍的提升，表明这些优化方法是切实可行且高效的。

  **结果可靠性分析** ：
  
  优化后的 SM2 算法依然能够成功完成加密解密以及签名验证等操作，且验证结果与优化前一致，说明在优化过程中没有改变算法的核心逻辑和安全性基础，优化后的算法在提升性能的同时保证了结果的正确性和可靠性。



## 四、实验结论与实验心得
深入理解了 SM2 算法的基本原理和实现步骤，包括密钥对生成、加密解密、签名验证等过程，掌握了其核心的数学基础和运算机制，为今后在信息安全领域的工作和学习奠定了坚实的理论基础。

在对 SM2 算法进行优化的过程中，学会了从算法的细节入手，分析其运算中的耗时环节，运用数学变换和坐标系转换等方法来提高算法效率，体会到了算法优化的重要性和挑战性，同时也认识到在实际应用中，性能优化对于提升系统的整体表现至关重要，需要不断地探索和尝试新的优化技术和方法。

通过构造签名误用场景和伪造签名实验，深刻认识到了随机数在数字签名算法中的关键作用以及安全使用的重要性，增强了对密码学算法安全性细节的关注度，明白了在实际的密码学应用中，任何一个小小的疏忽都可能导致严重的安全隐患，必须时刻保持严谨的态度，严格遵循安全规范和最佳实践，确保系统的安全性和可靠性。

实验过程中，也意识到理论与实践之间的差距，以及在实际编程实现密码学算法时可能会遇到的各种问题，如算法的正确性验证、不同编程环境下的性能表现差异等，这需要在今后的学习和实践中不断积累经验，提高自己的解决实际问题的能力。