# 实验一  SM4软件实现和优化
本实验共完成三种优化方法，分别为：

（一）利用查找表加速

（二）利用SIMD AVX2指令加速

（三）利用AES-NI指令集加速

## 利用查找表加速
通过预计算查表的方式，显著加速了SM4算法的执行，特别是轮函数（T函数）的计算部分。

### SM4算法中T函数原本的计算方式（未优化）
SM4的轮函数T(X)定义为：

T(X) = L(S(X)) = X ⊕ (X <<< 2) ⊕ (X <<< 10) ⊕ (X <<< 18) ⊕ (X <<< 24)

其中：
S(X) 是字节替换（S-box替换），对4个字节分别查S-box。
L(X) 是线性变换，包含多个循环左移和异或操作。

### 预计算T函数查表
将T函数整体预计算为4张32位查表（Table0~Table3）

每个表对应T函数中的一个字节输入，提前计算好所有256种可能输入对应的输出：

Table0[byte] = T(byte << 24)

Table1[byte] = T(byte << 16)

Table2[byte] = T(byte << 8)

Table3[byte] = T(byte << 0)

原本需要：4次S-box，4次移位，4次异或

现在需要：4次查表，4次异或

### 实验结果
<img src=".\截图\sm4 with t.png">  

## 利用SIMD AVX2指令加速
在原有 查表加速 的基础上，进一步引入了 SIMD 并行计算（AVX2 指令集） 来加速 SM4 加密/解密流程。

传统实现一次只能处理一个 128 位分组（即 1 个 SM4 块），而现代 CPU 支持 256 位 AVX2 指令集，一次可并行处理 8 个 SM4 块（128 位 × 8 = 1024 位）。

### 与原有方法理论性能对比：
| 维度     | 原始实现        | 查表优化  | SIMD+查表优化 |
| ------ | ----------- | ----- | -------------- |
| 每轮计算   | S-box+移位+异或 | 查表+异或 | 查表+异或+并行       |
| 每轮操作次数 | 高           | 中     | 极低             |
| 并行度    | 1 块         | 1 块   | 8 块            |
| 性能提升   | 1×          | 3~5×  | 10~20×     |
### 实验结果
<img src=".\截图\sm4 with t and simd.png">  

## 利用AES-NI指令集加速