# 实验一  SM4软件实现和优化
本实验由作者独立完成，共四种优化方法，分别为：

（一）利用查找表加速

（二）利用SIMD AVX2指令加速

（三）利用AES-NI指令集加速

（四）SM4-GCM工作模式软件优化

## 1. 利用查找表加速
通过预计算查表的方式，显著加速了SM4算法的执行，特别是轮函数（T函数）的计算部分。

### 1.1 SM4算法中T函数原本的计算方式（未优化）
SM4的轮函数T(X)定义为：

T(X) = L(S(X)) = X ⊕ (X <<< 2) ⊕ (X <<< 10) ⊕ (X <<< 18) ⊕ (X <<< 24)

其中：
S(X) 是字节替换（S-box替换），对4个字节分别查S-box。
L(X) 是线性变换，包含多个循环左移和异或操作。

### 1.2 预计算T函数查表
将T函数整体预计算为4张32位查表（Table0~Table3）

每个表对应T函数中的一个字节输入，提前计算好所有256种可能输入对应的输出：

Table0[byte] = T(byte << 24)

Table1[byte] = T(byte << 16)

Table2[byte] = T(byte << 8)

Table3[byte] = T(byte << 0)

原本需要：4次S-box，4次移位，4次异或

现在需要：4次查表，4次异或

### 1.3 实验结果
<img src=".\截图\sm4 with t.png">  

## 2. 利用SIMD AVX2指令加速
在原有 查表加速 的基础上，进一步引入了 SIMD 并行计算（AVX2 指令集） 来加速 SM4 加密/解密流程。

传统实现一次只能处理一个 128 位分组（即 1 个 SM4 块），而现代 CPU 支持 256 位 AVX2 指令集，一次可并行处理 8 个 SM4 块（128 位 × 8 = 1024 位）。

### 2.1 与原有方法理论性能对比：
| 维度     | 原始实现        | 查表优化  | SIMD+查表优化 |
| ------ | ----------- | ----- | -------------- |
| 每轮计算   | S-box+移位+异或 | 查表+异或 | 查表+异或+并行       |
| 每轮操作次数 | 高           | 中     | 极低             |
| 并行度    | 1 块         | 1 块   | 8 块            |
| 性能提升   | 1×          | 3~5×  | 10~20×     |
### 2.2 实验结果
<img src=".\截图\sm4 with t and simd.png">  

## 3. 利用AES-NI指令集加速

通过AES-NI 指令集实现了对 SM4 算法的硬件加速，其核心思想是：将 SM4 的 S-box 和线性变换（T函数）映射到 AES-NI 的 AESENC/AESENCLAST 指令上，从而利用 CPU 的 AES 硬件加速单元来执行原本属于 SM4 的运算。

虽然 SM4 和 AES 是不同的算法，但它们的结构相似：

都有轮函数

都有非线性字节替换（S-box）

都有线性变换（移位、异或）

因此，可以通过数学构造将 SM4 的 S-box 和线性变换映射为 AES 的 S-box 和 MixColumns 运算，从而复用 AES-NI 指令。

| 步骤 | 操作                     | 对应指令                     | 目的           |
| -- | ---------------------- | ------------------------ | ------------ |
| 1  | `AddTC`                | `_mm_xor_si128`          | 预处理：加常数      |
| 2  | `MulMatrixTA`          | `_mm_shuffle_epi8 + xor` | 线性变换（前）      |
| 3  | `_mm_aesenclast_si128` | AES-NI                   | 执行 AES S-box |
| 4  | `MulMatrixATA`         | `_mm_shuffle_epi8 + xor` | 线性变换（后）      |
| 5  | `AddATAC`              | `_mm_xor_si128`          | 后处理：加常数      |
### 3.1 与原有方法理论性能对比：
| 项目    | 传统实现  | AES-NI 优化实现              |
| ----- | ----- | ------------------------ |
| S-box | 软件查表  | 使用 AES-NI 的 `aesenclast` |
| 线性变换  | 移位+异或 | 通过 shuffle 和 xor 构造      |
| 并行度   | 1×    | 4×（128bit）               |
| 性能提升  | 1×    | **5~10×**（实测）            |
| 依赖    | 纯软件   | Intel AES-NI 指令集         |

### 3.2 实验结果
<img src=".\截图\sm4 with aes-ni.png">  


## 4. SM4-GCM工作模式软件优化

通过软件层面的优化手段提升SM4-GCM模式的性能。其核心思想是：对SM4-GCM中的关键运算进行算法改进和代码级优化，充分利用现代CPU的指令集和并行计算能力。

SM4-GCM模式的主要性能瓶颈在于：
1. GCM模式中的GHASH运算
2. SM4加密过程中的非线性变换和线性变换
3. 计数器模式下的数据生成

软件优化的关键在于对这些计算密集型部分进行加速。

| 步骤 | 操作                     | 优化方法                     | 目的           |
| ---- | ------------------------ | ---------------------------- | -------------- |
| 1    | GHASH函数优化            | 预计算 + 批量处理           | 减少重复计算   |
| 2    | 计数器模式优化           | 向量化计数器更新            | 提高计数效率   |
| 3    | SM4加密函数优化          | 查表法 + 数据预取           | 加速非线性变换 |
| 4    | 并行块处理               | 多线程 + 数据分块           | 利用多核性能   |
| 5    | 内存访问模式优化         | 数据对齐 + 缓存友好的访问   | 减少缓存未命中 |

### 4.1 与原有方法理论性能对比：

| 项目                | 传统实现              | 软件优化实现               |
| ------------------- | --------------------- | -------------------------- |
| GHASH计算           | 逐块串行计算          | 批量处理 + 预计算          |
| 计数器更新          | 单字节操作            | 128位批量更新              |
| SM4加密             | 查表 + 顺序执行       | 预取指令 + 并行查表        |
| 并行处理能力        | 单线程               | 多线程                    |
| 内存访问效率        | 随机访问              | 顺序访问 + 对齐            |
| 性能提升（理论）    | 1×                   | 3~5×（取决于数据量）   |
| 依赖                | 通用指令集           | SSE4.1及以上指令集         |

### 4.2 优化细节

1. **GHASH函数优化**：
   - 实现了基于64位预计算表的GHASH计算方法
   - 批量处理16个块数据，减少循环控制开销

2. **计数器模式优化**：
   - 使用128位批量计数器更新逻辑
   - 预计算多个计数器值减少加密过程中的计算负担

3. **SM4加密函数优化**：
   - 采用8表并行查表法减少查表次数
   - 使用指令预取技术减少缓存延迟

4. **并行处理**：
   - 实现多线程分块处理
   - 使用工作窃取算法动态平衡线程负载

5. **内存访问优化**：
   - 数据对齐至16字节边界
   - 优化内存访问模式为顺序访问

这些优化措施充分挖掘了现代CPU的计算潜力，显著提升了SM4-GCM模式的软件实现性能。

### 4.3 实验结果
<img src=".\截图\sm4-gcm.png">  


## 5. 实验结论与心得
### 5.1 实验结论
1.性能显著提升：

通过本次实验，我们成功实现了SM4算法的四种优化方法，包括利用查找表加速、SIMD AVX2指令加速、AES-NI指令集加速以及SM4-GCM工作模式软件优化。实验结果表明，这些优化方法相较于传统实现方式，性能提升显著。

2.优化方法有效性：

每种优化方法都有其独特的应用场景和优势。

查找表优化适用于需要频繁调用T函数的场景，能够减少计算复杂度；

SIMD AVX2指令优化充分发挥了现代CPU的并行计算能力，适合处理大量数据；

AES-NI指令集优化则借助硬件加速能力，为SM4算法提供了高效实现；

SM4-GCM工作模式软件优化则针对特定工作模式下的性能瓶颈，通过算法改进和代码级优化提升了整体性能。

这些优化方法在各自的适用场景下均表现出色，验证了其有效性。

### 5.2 心得体会
1.深入理解SM4算法：

在实验过程中，我对SM4算法的原理和结构有了更深入的理解。从T函数的计算到GCM工作模式的实现，每一个细节都让我对SM4算法有了更全面的认识。这不仅加深了我对密码学知识的理解，也为我今后在相关领域的学习和研究打下了坚实的基础。

2.掌握优化技巧：

通过本次实验，我熟练掌握了多种软件优化技巧，包括查找表预计算、SIMD指令集应用、AES-NI指令集加速以及针对特定工作模式的算法改进等。这些技巧不仅适用于SM4算法，也为我解决其他计算密集型问题提供了宝贵的思路和方法。