# 实验四：SM3 的实现优化与应用

## 一、实验目标

  1. **SM3 实现与优化** ：掌握 SM3 算法的基本实现方法，并探索优化途径以提高其运算效率。
  2. **长度扩展攻击验证** ：理解长度扩展攻击原理，并通过实验验证其可行性。
  3. **Merkle 树叶子节点的存在性证明** ：学习 Merkle 树的构建方法，以及如何通过存在性证明验证叶子节点是否属于该树。

## 二、实验内容

### 2.1 SM3 实现与优化

#### 2.1.1 SM3算法的基础实现

基础实现是严格按照SM3算法标准进行的完整实现，主要包含以下关键步骤：

（1）消息预处理（填充与分块）

将输入的消息转换为字节数组，并进行必要的填充操作，使其长度满足SM3算法要求的512位倍数。具体步骤如下：
- 添加填充字节0x80，表示消息的结束。
- 用0x00填充，直到消息长度加上64位后是512的倍数。
- 在填充后的消息末尾附加一个64位的计数器，表示原始消息的长度（以比特为单位）。

（2）初始化

初始化哈希值（V）和常数T：
- 哈希值V初始化为8个32位的十六进制常数：0x7380166F, 0x4914B2B9, 0x172442D7, 0xDA8A0600, 0xA96F30BC, 0x163138AA, 0xE38DEE4D, 0xB0FB0E4E。
- 常数T初始化：前16个元素为0x79CC4519，后48个元素为0x7A879D8A。

（3）消息扩展

将512位的消息块扩展为68个32位字（W）和64个32位字（W1）：
- 将消息块分为16个32位字，存入W数组的前16个位置。
- 通过循环移位和异或运算，生成剩余的52个字，扩展到W数组的第17到68个位置。
- 计算W1数组的每个元素为W数组中对应位置元素与后4个元素的异或值。

（4）压缩函数

通过迭代运算更新哈希值，使用非线性变换（如逻辑运算和循环移位）确保哈希结果的复杂性和随机性：
- 初始化压缩函数的变量A、B、C、D、E、F、G、H为当前哈希值V。
- 对于每个消息块，进行64轮迭代运算，根据轮次j选择不同的逻辑运算和常数进行计算。
- 更新变量A到H的值，最终将结果异或回哈希值V中。

#### 2.1.2 SM3算法的优化实现

为了提升SM3算法的性能，实验实现了多个优化版本，每个版本针对特定部分进行改进：

（1）优化1：预计算常数T

在优化版本1中，常数T被预计算并作为静态数组存储。这样可以避免每次调用时的初始化开销，减少函数调用的频繁程度，从而提高执行效率。

（2）优化2：优化消息扩展逻辑

在消息扩展阶段，通过调整计算顺序和减少不必要的中间变量，降低计算复杂度。优化后的消息扩展逻辑更紧凑，减少了内存访问次数和计算步骤。

（3）优化3：调整压缩函数变量更新顺序

在压缩函数的迭代过程中，调整变量更新的顺序，使得某些操作可以提前进行或合并执行，从而减少总体的运算步骤。

（4）优化4：综合优化策略

优化版本4结合了预计算常数T、优化消息扩展逻辑和调整变量更新顺序的策略，通过综合应用多种优化方法，进一步提升算法的性能表现。

#### 2.1.3 性能测试与验证

为了验证优化策略的有效性和正确性，实验进行了以下测试：
- **正确性验证**：对比所有版本的输出哈希值，确保优化后的算法与基础版本输出相同的结果，证明优化未引入逻辑错误。
- **性能测试**：使用相同的输入消息，测量并记录每个版本的执行时间，分析不同优化策略对性能的影响。

#### 运行结果
<img src=".\运行结果截图\sm3实现与优化.png"> 

| 实现版本  | 执行时间（ms） | 性能提升百分比（相对于基础版） |
| ----- | -------- | --------------- |
| 基础版本  | 0.0718   | -               |
| 优化版本1 | 0.0543   | 24.4%           |
| 优化版本2 | 0.062    | 13.7%           |
| 优化版本3 | 0.0675   | 6.0%            |
| 优化版本4 | 0.0525   | 26.9%           |



### 2.2 长度扩展攻击验证

#### 1. 基础哈希计算

首先，对原始消息“Hollow world!”使用SM3算法进行哈希计算，获取其哈希值。这一过程是长度扩展攻击的基础，为后续攻击提供必要的初始条件。

#### 2. 构造伪造消息

将原始消息与填充数据以及附加消息“this is SDU DUDU!”组合，形成伪造消息。填充数据是根据原始消息长度按照SM3算法要求生成的，以确保伪造消息的格式符合哈希计算的要求。

#### 3. 长度扩展攻击模拟

利用从原始消息哈希值中提取的中间状态（IV），模拟长度扩展攻击过程。通过调用`sm3_hash_from_iv`函数，以附加消息为输入，结合原始消息的长度信息，计算出伪造消息的哈希值。

#### 4. 直接哈希计算验证

直接对伪造消息进行SM3哈希计算，获取其哈希值。通过对比长度扩展攻击得到的哈希值与直接计算得到的哈希值，验证长度扩展攻击的有效性。

#### 实验结果

实验结果显示，直接对伪造消息进行哈希计算得到的哈希值与通过长度扩展攻击得到的哈希值完全一致，表明攻击成功。

<img src=".\运行结果截图\长度扩展攻击.png"> 


### 2.3 Merkle 树叶子节点的存在性证明

#### 2.3.1 Merkle树构建

1. **叶子数据生成**：创建一个包含100,000个叶子节点的数据集，每个叶子节点的数据格式为“叶子数据 索引”，例如“叶子数据 0”、“叶子数据 1”，直到“叶子数据 99999”。
2. **叶子节点哈希计算**：对每个叶子节点的数据进行哈希运算，生成对应的哈希值。这一步使用了SM3哈希算法，每个叶子节点的哈希值将作为Merkle树的底层节点。
3. **树结构构建**：从底层叶子节点开始，逐层向上构建Merkle树。每两个相邻的节点哈希值将被合并并再次哈希，生成上一层的节点哈希值。这个过程持续进行，直到最终生成一个根哈希值，代表整个树的哈希值。

#### 2.3.2 存在性证明验证

1. **选择测试节点**：选择两个特定的叶子节点进行测试，一个存在于Merkle树中（例如索引99999），另一个不存在于树中（例如索引100003）。
2. **生成存在性证明**：为每个测试节点生成存在性证明。这包括从叶子节点到根节点的路径上所有兄弟节点的哈希值。这些哈希值将用于在验证过程中重新计算路径哈希。
3. **验证存在性证明**：
   - 对于存在的叶子节点，使用其数据和存在性证明中的兄弟节点哈希值，重新计算路径哈希，并与根哈希值进行比较。如果计算得到的根哈希值与实际的根哈希值一致，则验证通过，证明该节点存在于Merkle树中。
   - 对于不存在的叶子节点，同样使用其数据和存在性证明中的兄弟节点哈希值重新计算路径哈希。如果计算得到的根哈希值与实际的根哈希值不一致，则验证失败，证明该节点不存在于Merkle树中。

#### 2.3.3 实验结果输出

1. **Merkle树构建结果**：输出构建完成的Merkle树的根哈希值，用于标识整个树的哈希值。
2. **存在性验证结果**：
   - 对于存在的叶子节点，输出其索引和数据，以及存在性验证通过的消息。
   - 对于不存在的叶子节点，输出其索引和数据，以及存在性验证失败的消息。

#### 实验结果

对于索引99999的叶子节点，存在性验证通过，证明该节点存在于Merkle树中。对于索引100003的叶子节点，存在性验证失败，证明该节点不存在于Merkle树中。

<img src=".\运行结果截图\merkle_tree.png"> 

## 三、实验分析

### （一）SM3 实现与优化

  1. 基本实现正确性分析：通过与已知 SM3 哈希结果对比，验证所编写的 SM3 实现代码的正确性。
  2. 优化效果评估：从图表和表格可以看出，优化版本1和优化版本4的性能提升最为显著，分别达到了24.4%和26.9%。优化版本2和优化版本3的性能提升相对较小，但依然有一定改进。总体来看，优化策略对SM3算法的性能提升效果明显，尤其是预计算常数T和综合优化策略的效果最为突出。

  | 实现版本  | 执行时间（ms） | 性能提升百分比（相对于基础版） |
| ----- | -------- | --------------- |
| 基础版本  | 0.0718   | -               |
| 优化版本1 | 0.0543   | 24.4%           |
| 优化版本2 | 0.062    | 13.7%           |
| 优化版本3 | 0.0675   | 6.0%            |
| 优化版本4 | 0.0525   | 26.9%           |

### （二）长度扩展攻击验证

  长度扩展攻击的成功表明，SM3算法在设计上存在潜在的脆弱性。攻击者可以利用哈希函数的长度扩展性质，在知道原始消息哈希值的情况下，构造出伪造消息及其对应的哈希值，而无需知道原始消息的具体内容。这在某些特定场景下可能对系统的安全性构成威胁，例如当哈希函数用于消息认证码（MAC）时。

### （三）Merkle 树叶子节点的存在性证明

  1. 证明正确性验证：通过大量实验，验证生成的存在性证明能否正确验证叶子节点的存在性。检查在叶子节点存在和不存在两种情况下，验证结果是否准确。
  2. 性能分析：通过存在性证明验证，可以高效地验证特定数据是否存在于大规模数据集中，而无需传输和验证整个数据集。这展示了Merkle树在数据完整性验证和高效数据同步方面的优势。

## 四、实验结论与实验心得

### （一）实验结论

  1. **SM3 实现与优化** ：成功实现了 SM3 算法，并通过优化措施显著提高了其运行效率。优化后的代码在处理不同长度的消息时，均能快速准确地计算出哈希值，满足实际应用对哈希函数性能的要求。
  2. **长度扩展攻击验证** ：验证了长度扩展攻击的可行性，加深了对哈希函数安全特性的理解。同时，明确了在实际应用中需要采取相应的防御措施，以防止因长度扩展攻击导致的安全风险。
  3. **Merkle 树叶子节点的存在性证明** ：掌握了 Merkle 树的构建方法和存在性证明的生成与验证过程。实验结果表明，该方法能够高效、准确地验证叶子节点是否属于 Merkle 树，为分布式系统、区块链等领域中的数据完整性验证提供了一种可靠的技术手段。

### （二）实验心得

  1. 通过本次实验，深入理解了 SM3 算法的原理和实现细节，以及其在实际应用中的优化策略。这不仅提升了对密码学哈希函数的认识，还培养了代码优化的能力和技巧。
  2. 长度扩展攻击验证实验让我意识到信息安全领域中潜在的风险和威胁，以及采取有效防御措施的重要性。在今后的学习和开发中，将更加注重代码的安全性设计。
  3. Merkle 树实验让我领略到其在数据结构和信息安全交叉领域的独特魅力。了解了如何利用密码学技术构建高效、安全的数据结构，为今后在相关领域的研究和应用打下了基础。
